# AlgoLabs

## first_lab:

* TASK:

Варіант 1
Потрібно написати програму для обходу двовимірного масиву розміром NxM у форматі "зігзагу". Зігзаговий обхід означає, що спочатку ми рухаємось по діагоналях масиву, пчинаючи з лівої верхньої точки. Другим елементом буде виведено елемент, який знаходиться справа, потім знизу і ліворуч, далі ще крок вниз і рухаємось по діагоналі знову вправо. Для масиву розміром 3x3 обхід у форматі зігзагу виглядає так (де номер у клітинці відповідає порядку її відвідин):

1 2 6 3 5 7 4 8 9

Для масиву 3 х 5 це матиме вигляд:

1 2 6 7 12 3 5 8 11 13 4 9 10 14 15

Реалізуйте алгоритм, який отримає на вхід масив розміром m та n та поверне одномірний масив з значеннями елементів вхідного масиву при обході його у порядку, зазначеному вище у задачі

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6, n == m == 1 

* Branch: https://github.com/serejek2004/AlgoLabs/tree/first_lab

## second_lab

* TASK:

Варіант 1
Love

Андрій закоханий у Ілону. Вони вирішили провести День святого Валентина разом в Ашані, але Андрій, як ми всі знаємо, дуже зайнятий на роботі, тому він не зміг прийти. Тепер якраз Ілона знову наповнена гнівом і готова його вбити. Але є щось, що ви можете зробити.

Андрій розповідає Ілоні, що він програміст-початківець і, як правило, зайнятий вирішенням важливих проблем на проекті. Тож Ілона вирішує перевірити його алгоритмічні навички. Вона пише масив N цілих чисел. Вона дає йому число P і запитує, чи може він знайти три ( тільки три) цілих числа Ai Aj Ak (i ≠ j ≠ k) в масиві, сума якого дорівнює числу P, тобто

Ai + Aj + Ak  = P

Отже, чим швидше Андрій скаже відповідь “Такі числа є” або “Таких чисел немає” тим швидше він отримає поцілунок

Вхідні дані: Масив цілих чисел A1, A2 A3 ……………. AN  Р - Шукане число 

Обмеження 3<= N <= 1000 1<= Ai <= 10^9 де 1<= i <=N 1<= P <= 3*10^9

Приклад

Input 1 2 3 6

Output True

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище

* Branch: https://github.com/serejek2004/AlgoLabs/tree/second_lab

## third_lab

* TASK:

Варіант 1
Для бінарного дерева знайдіть суму всіх листків, які є лівими дітьми.

Реалізуйте функцію, яка отримує на вхід кореневий вузол дерева, та повертає значення суми branchSums:

def branchSums(root):
	pass
Вхідні дані: Дерево подається у вигляді вузлів, де кожен вузол має ціле значення. Корінь дерева завжди не є лівим листом

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
Вихідні дані: Сума всіх лівих листів у бінарному дереві.

* Branch: https://github.com/serejek2004/AlgoLabs/tree/third_lab
